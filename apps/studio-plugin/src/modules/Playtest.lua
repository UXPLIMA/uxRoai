local HttpService = game:GetService("HttpService")
local LogService = game:GetService("LogService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local StarterPlayer = game:GetService("StarterPlayer")
local StudioTestService = game:GetService("StudioTestService")

local M = {}

function M.installHarness(serverTestSource, clientTestSource)
	ScriptWriter.ensureRootHarness()

	local starterPlayerScripts = StarterPlayer:FindFirstChild("StarterPlayerScripts")
	if not starterPlayerScripts then
		starterPlayerScripts = StarterPlayer:WaitForChild("StarterPlayerScripts")
	end

	local serverSource = ScriptWriter.injectTestCode(
		HarnessTemplates.ServerScript,
		"--[[UXROAI_SERVER_TEST_CODE]]",
		serverTestSource or ""
	)

	local clientSource = ScriptWriter.injectTestCode(
		HarnessTemplates.ClientScript,
		"--[[UXROAI_CLIENT_TEST_CODE]]",
		clientTestSource or ""
	)

	local _, serverChange = ScriptWriter.upsertScript(
		ServerScriptService,
		"Script",
		Constants.PLAYTEST_SERVER_SCRIPT_NAME,
		serverSource
	)

	local _, clientChange = ScriptWriter.upsertScript(
		starterPlayerScripts,
		"LocalScript",
		Constants.PLAYTEST_CLIENT_SCRIPT_NAME,
		clientSource
	)

	UI.appendLog(I18N.t("logHarnessInstalled"))
	return {
		type = "ensure_playtest_harness",
		summary = "Playtest harness ready",
		details = {
			scriptCount = 2,
			version = 2,
		},
		changes = { serverChange, clientChange },
	}
end

function M.cleanupHarness()
	local removedCount = 0

	local serverScript = ServerScriptService:FindFirstChild(Constants.PLAYTEST_SERVER_SCRIPT_NAME)
	if serverScript and serverScript:IsA("Script") then
		serverScript:Destroy()
		removedCount = removedCount + 1
	end

	local starterPlayerScripts = StarterPlayer:FindFirstChild("StarterPlayerScripts")
	if starterPlayerScripts then
		local clientScript = starterPlayerScripts:FindFirstChild(Constants.PLAYTEST_CLIENT_SCRIPT_NAME)
		if clientScript and clientScript:IsA("LocalScript") then
			clientScript:Destroy()
			removedCount = removedCount + 1
		end
	end

	local rootFolder = ReplicatedStorage:FindFirstChild(Constants.ROOT_FOLDER_NAME)
	if rootFolder then
		rootFolder:Destroy()
	end

	UI.appendLog(I18N.t("logHarnessRemoved"))
	return {
		removedScripts = removedCount,
	}
end

function M.executePlaytest(playtest)
	if type(playtest) ~= "table" then
		error("Playtest payload is not a table")
	end

	M.installHarness(playtest.serverTest, playtest.clientTest)

	local payload = {
		kind = "uxroai_playtest",
		goal = playtest.goal or "Generated by uxRoai",
		timeoutSeconds = playtest.timeoutSeconds or 120,
		minDurationSeconds = playtest.minDurationSeconds or 10,
		version = 2,
		serverTest = playtest.serverTest or "",
		clientTest = playtest.clientTest or "",
	}

	UI.appendLog(I18N.t("logPlaytestStart"))

	local runtimeErrors = {}
	local messageConnection = LogService.MessageOut:Connect(function(message, messageType)
		if messageType == Enum.MessageType.MessageError then
			table.insert(runtimeErrors, tostring(message))
		end
	end)

	local ok, result = pcall(function()
		return StudioTestService:ExecutePlayModeAsync(payload)
	end)
	messageConnection:Disconnect()

	local cleanupInfo = {
		removedScripts = 0,
	}
	local cleanupOk, cleanupResult = pcall(M.cleanupHarness)
	if cleanupOk and type(cleanupResult) == "table" then
		cleanupInfo = cleanupResult
	else
		UI.appendLog(I18N.t("logWarningPrefix", { warning = "Harness cleanup failed" }))
	end

	if not ok then
		error("ExecutePlayModeAsync failed: " .. tostring(result))
	end

	local ignoredRuntimeErrors = {}
	local fatalRuntimeErrors = {}
	for _, message in ipairs(runtimeErrors) do
		local text = string.lower(tostring(message))
		local isIgnorable =
			string.find(text, "failed to load sound", 1, true) ~= nil
			or string.find(text, "asset type does not match requested type", 1, true) ~= nil

		if isIgnorable then
			table.insert(ignoredRuntimeErrors, tostring(message))
		else
			table.insert(fatalRuntimeErrors, tostring(message))
		end
	end

	if #ignoredRuntimeErrors > 0 then
		UI.appendLog(
			I18N.t("logWarningPrefix", {
				warning = "Ignored non-fatal runtime warnings: " .. tostring(#ignoredRuntimeErrors),
			})
		)
	end

	if #fatalRuntimeErrors > 0 then
		UI.appendLog("Playtest runtime errors detected: " .. tostring(#fatalRuntimeErrors))
		local maxLogCount = math.min(#fatalRuntimeErrors, 6)
		for index = 1, maxLogCount do
			UI.appendLog("RuntimeError: " .. fatalRuntimeErrors[index])
		end
	end

	local resultText = tostring(result)
	if type(result) == "table" then
		result.runtimeErrors = fatalRuntimeErrors
		result.runtimeWarnings = ignoredRuntimeErrors
		result.harnessCleanup = cleanupInfo

		if result.ok == false then
			local failedAssertions = type(result.failedAssertions) == "table" and result.failedAssertions or {}
			if #failedAssertions > 0 then
				local shown = {}
				for i = 1, math.min(#failedAssertions, 3) do
					table.insert(shown, failedAssertions[i])
				end
				result.errorSummary = #failedAssertions .. " assertion(s) failed: " .. table.concat(shown, " | ")
			elseif #fatalRuntimeErrors > 0 then
				result.errorSummary = #fatalRuntimeErrors .. " runtime error(s)"
			end
		end
		if #fatalRuntimeErrors > 0 then
			result.ok = false
			if not result.errorSummary then
				result.errorSummary = tostring(#fatalRuntimeErrors) .. " runtime error(s) captured during playtest."
			end
		end
	end

	if type(result) == "table" and resultText == tostring(result) then
		local encodeOk, encoded = pcall(function()
			return HttpService:JSONEncode(result)
		end)
		if encodeOk then
			resultText = encoded
		end
	end

	UI.appendLog(I18N.t("logPlaytestResult", { result = resultText }))

	if type(result) == "table" then
		return result
	end
	return {
		ok = #fatalRuntimeErrors == 0,
		raw = resultText,
		runtimeErrors = fatalRuntimeErrors,
		runtimeWarnings = ignoredRuntimeErrors,
		harnessCleanup = cleanupInfo,
	}
end

function M.collectExecutionIssues(changeEntries, playtestPassed)
	local issues = {}
	for _, change in ipairs(changeEntries) do
		if type(change) == "table" then
			local details = type(change.details) == "table" and change.details or {}
			local propertyFail = tonumber(details.propertyFail) or 0
			if propertyFail > 0 and not playtestPassed then
				table.insert(
					issues,
					tostring(change.type or "action")
						.. " has "
						.. tostring(propertyFail)
						.. " property assignment failure(s)."
				)
			end
			if type(details.error) == "string" and details.error ~= "" then
				table.insert(
					issues,
					tostring(change.type or "action") .. " failed: " .. tostring(details.error)
				)
			end

			local playtestResult = change.playtestResult
			if type(playtestResult) == "table" then
				-- Include failed assertion labels with full detail
				if playtestResult.ok == false then
					local failedAssertions = type(playtestResult.failedAssertions) == "table" and playtestResult.failedAssertions or {}
					if #failedAssertions > 0 then
						local shown = {}
						for i = 1, math.min(#failedAssertions, 8) do
							table.insert(shown, "  - " .. tostring(failedAssertions[i]))
						end
						table.insert(issues, "Playtest FAILED â€” " .. tostring(#failedAssertions) .. " assertion(s) failed:\n" .. table.concat(shown, "\n"))
					else
						local errorSummary = tostring(playtestResult.errorSummary or "unknown reason")
						table.insert(issues, "Playtest failed: " .. errorSummary)
					end
				end

				-- Include runtime errors with full text (stack traces preserved by xpcall)
				local rtErrors = type(playtestResult.runtimeErrors) == "table" and playtestResult.runtimeErrors or {}
				if #rtErrors > 0 then
					local errorMessages = {}
					local maxErrors = math.min(#rtErrors, 8)
					for errIdx = 1, maxErrors do
						local errEntry = rtErrors[errIdx]
						local errMsg = ""
						if type(errEntry) == "string" then
							errMsg = errEntry
						elseif type(errEntry) == "table" then
							errMsg = tostring(errEntry.message or errEntry.error or errEntry[1] or "")
						end
						if errMsg ~= "" then
							table.insert(errorMessages, "  - " .. errMsg)
						end
					end
					if #errorMessages > 0 then
						table.insert(issues, "Playtest runtime errors (" .. tostring(#rtErrors) .. "):\n" .. table.concat(errorMessages, "\n"))
					else
						table.insert(issues, "Playtest runtime errors: " .. tostring(#rtErrors) .. " (no details)")
					end
				end

				-- Include runtime warnings that may indicate API misuse
				local rtWarnings = type(playtestResult.runtimeWarnings) == "table" and playtestResult.runtimeWarnings or {}
				if #rtWarnings > 0 and not playtestPassed then
					local warnMessages = {}
					local maxWarns = math.min(#rtWarnings, 5)
					for wIdx = 1, maxWarns do
						table.insert(warnMessages, "  - " .. tostring(rtWarnings[wIdx]))
					end
					table.insert(issues, "Playtest runtime warnings:\n" .. table.concat(warnMessages, "\n"))
				end

				-- Include console output excerpt for context (server/client logs)
				local consoleOutput = type(playtestResult.consoleOutput) == "table" and playtestResult.consoleOutput or {}
				if #consoleOutput > 0 and not playtestPassed then
					local logLines = {}
					-- Take last N lines (most relevant)
					local startIdx = math.max(1, #consoleOutput - 14)
					for cIdx = startIdx, #consoleOutput do
						table.insert(logLines, "  " .. tostring(consoleOutput[cIdx]))
					end
					if #logLines > 0 then
						table.insert(issues, "Playtest console output (last " .. tostring(#logLines) .. " lines):\n" .. table.concat(logLines, "\n"))
					end
				end

				-- Include server/client error details
				local serverResult = type(playtestResult.serverResult) == "table" and playtestResult.serverResult or {}
				if serverResult.ok == false and type(serverResult.error) == "string" and serverResult.error ~= "" then
					table.insert(issues, "Server test error: " .. serverResult.error)
				end
				local clientResult = type(playtestResult.clientResult) == "table" and playtestResult.clientResult or {}
				if clientResult.ok == false and type(clientResult.error) == "string" and clientResult.error ~= "" then
					table.insert(issues, "Client test error: " .. clientResult.error)
				end
			end
		end
	end
	return issues
end

return M
