import { safeString, clampNumber, isVector, normalizeVector } from "./helpers.js";
import { normalizePlaytest } from "./normalize-playtest.js";

const MAX_EDITS = 50;
const MAX_VARIANTS = 300;
const MAX_MASS_CREATE = 200;
const MAX_TARGET_PATHS = 500;
const MAX_SMART_DUPLICATE = 50;

const SUPPORTED_ACTIONS = new Set([
  "create_instance",
  "upsert_script",
  "edit_script",
  "set_property",
  "delete_instance",
  "query_instances",
  "bulk_set_properties",
  "clone_template_to_variants",
  "create_reactive_binding",
  "set_attribute",
  "add_tag",
  "remove_tag",
  "run_code",
  "mass_create",
  "get_instance_properties",
  "get_class_info",
  "insert_script_lines",
  "delete_script_lines",
  "set_relative_property",
  "smart_duplicate",
  "insert_asset",
  "inject_instance",
  "ensure_playtest_harness",
  "run_playtest",
]);

// ── Per-action normalizers ─────────────────────────────────────────

function normalizeCreateInstance(action, out) {
  out.parentPath = safeString(action.parentPath, "game.Workspace");
  out.className = safeString(action.className, "Folder");
  out.name = safeString(action.name, "NewInstance");
  out.properties =
    action.properties && typeof action.properties === "object"
      ? action.properties
      : {};
  return true;
}

function normalizeUpsertScript(action, out) {
  out.parentPath = safeString(action.parentPath, "game.ServerScriptService");
  out.name = safeString(action.name, "GeneratedScript");
  out.runContext = safeString(action.runContext, "server");
  out.source = safeString(action.source, "-- generated by uxRoai");
  return true;
}

function normalizeSetProperty(action, out) {
  out.path = safeString(action.path);
  out.property = safeString(action.property);
  out.value = action.value;
  return true;
}

function normalizeDeleteInstance(action, out) {
  out.path = safeString(action.path);
  return true;
}

function normalizeQuery(query) {
  if (!query || typeof query !== "object") {
    return { rootPath: "game", maxResults: 200 };
  }

  const out = {
    rootPath: safeString(query.rootPath, "game"),
    className: safeString(query.className),
    nameContains: safeString(query.nameContains),
    pathContains: safeString(query.pathContains),
    recursive: query.recursive !== false,
    maxResults: clampNumber(query.maxResults, 1, 2000, 200),
  };

  const propName = safeString(query.propertyName || query.property);
  if (propName) {
    out.propertyName = propName;
    out.propertyValue = query.propertyValue ?? query.value;
  }

  const scriptContains = safeString(query.scriptContentContains || query.scriptContains);
  if (scriptContains) {
    out.scriptContentContains = scriptContains.slice(0, 500);
  }

  const hasTag = safeString(query.hasTag || query.tag);
  if (hasTag) {
    out.hasTag = hasTag;
  }

  const hasAttribute = safeString(query.hasAttribute || query.attributeName);
  if (hasAttribute) {
    out.hasAttribute = hasAttribute;
    if (query.attributeValue !== undefined) {
      out.attributeValue = query.attributeValue;
    }
  }

  return out;
}

function normalizeQueryInstances(action, out) {
  out.query = normalizeQuery(action.query || action);
  return true;
}

function normalizeBulkSetProperties(action, out) {
  out.targetPaths = Array.isArray(action.targetPaths)
    ? action.targetPaths.map((item) => safeString(item)).filter(Boolean).slice(0, MAX_TARGET_PATHS)
    : [];
  out.query = normalizeQuery(action.query || {});
  out.properties =
    action.properties && typeof action.properties === "object"
      ? action.properties
      : {};
  return true;
}

function normalizeCloneTemplateToVariants(action, out) {
  const rawVariants = Array.isArray(action.variants) ? action.variants : [];
  const variants = [];
  for (const variant of rawVariants) {
    if (typeof variant === "string") {
      const name = safeString(variant).slice(0, 200);
      if (name) {
        variants.push({ name, propertyOverrides: {} });
      }
      continue;
    }
    if (variant && typeof variant === "object") {
      const name = safeString(variant.name).slice(0, 200);
      if (!name) continue;
      variants.push({
        name,
        propertyOverrides:
          variant.propertyOverrides && typeof variant.propertyOverrides === "object"
            ? variant.propertyOverrides
            : {},
      });
    }
  }

  out.templatePath = safeString(action.templatePath);
  out.parentPath = safeString(action.parentPath);
  out.deleteIfExists = action.deleteIfExists !== false;
  out.variants = variants.slice(0, MAX_VARIANTS);
  return true;
}

function normalizeCreateReactiveBinding(action, out) {
  const rawRules = Array.isArray(action.rules) ? action.rules : [];
  const rules = [];
  for (const rule of rawRules) {
    if (!rule || typeof rule !== "object") continue;
    const op = safeString(rule.op);
    if (!["contains", "equals", "gte", "lte"].includes(op)) continue;
    rules.push({ op, value: rule.value, set: rule.set });
  }

  out.parentPath = safeString(action.parentPath, "game.StarterPlayer.StarterPlayerScripts");
  out.name = safeString(action.name, "UxRoaIReactiveBinding");
  out.sourceGuiPath = safeString(action.sourceGuiPath);
  out.targetGuiPath = safeString(action.targetGuiPath);
  out.sourceProperty = safeString(action.sourceProperty, "Text");
  out.targetProperty = safeString(action.targetProperty, "Visible");
  out.rules = rules.slice(0, 120);
  out.defaultValue = action.defaultValue;
  return true;
}

function normalizeEditScript(action, out) {
  out.path = safeString(action.path);
  if (!out.path) return false;
  out.edits = Array.isArray(action.edits)
    ? action.edits.map(e => ({
        oldText: safeString(e.oldText || e.old || e.search),
        newText: safeString(e.newText || e.new || e.replace),
      })).filter(e => e.oldText !== "")
      .slice(0, MAX_EDITS)
    : [];
  if (out.edits.length === 0) return false;
  return true;
}

function normalizeSetAttribute(action, out) {
  out.path = safeString(action.path);
  if (!out.path) return false;
  out.attribute = safeString(action.attribute || action.name);
  if (!out.attribute) return false;
  out.value = action.value;
  return true;
}

function normalizeAddTag(action, out) {
  out.path = safeString(action.path);
  if (!out.path) return false;
  out.tag = safeString(action.tag || action.name);
  if (!out.tag) return false;
  return true;
}

function normalizeRemoveTag(action, out) {
  out.path = safeString(action.path);
  if (!out.path) return false;
  out.tag = safeString(action.tag || action.name);
  if (!out.tag) return false;
  return true;
}

function normalizeRunCode(action, out) {
  out.source = safeString(action.source);
  if (!out.source) return false;
  out.description = safeString(action.description, "Run custom Luau code");
  return true;
}

function normalizeMassCreate(action, out) {
  const rawObjects = Array.isArray(action.objects) ? action.objects : [];
  out.objects = rawObjects
    .filter((o) => o && typeof o === "object" && safeString(o.className))
    .slice(0, MAX_MASS_CREATE)
    .map((o) => ({
      className: safeString(o.className, "Part"),
      parentPath: safeString(o.parentPath, "game.Workspace"),
      name: safeString(o.name, "Instance"),
      properties:
        o.properties && typeof o.properties === "object" ? o.properties : {},
    }));
  if (out.objects.length === 0) return false;
  return true;
}

function normalizeGetInstanceProperties(action, out) {
  out.path = safeString(action.path);
  if (!out.path) return false;
  return true;
}

function normalizeGetClassInfo(action, out) {
  out.className = safeString(action.className);
  if (!out.className) return false;
  return true;
}

function normalizeInsertScriptLines(action, out) {
  out.path = safeString(action.path);
  if (!out.path) return false;
  out.afterLine = clampNumber(action.afterLine, 0, 100000, 0);
  out.content = safeString(action.content);
  if (!out.content) return false;
  return true;
}

function normalizeDeleteScriptLines(action, out) {
  out.path = safeString(action.path);
  if (!out.path) return false;
  let startLine = clampNumber(action.startLine, 1, 100000, 1);
  let endLine = clampNumber(action.endLine, 1, 100000, 1);
  if (startLine > endLine) {
    [startLine, endLine] = [endLine, startLine];
  }
  out.startLine = startLine;
  out.endLine = endLine;
  return true;
}

function normalizeSetRelativeProperty(action, out) {
  const paths = Array.isArray(action.paths)
    ? action.paths.map((p) => safeString(p)).filter(Boolean).slice(0, MAX_TARGET_PATHS)
    : action.path
      ? [safeString(action.path)].filter(Boolean)
      : [];
  if (paths.length === 0) return false;
  out.paths = paths;
  out.property = safeString(action.property);
  if (!out.property) return false;
  const op = safeString(action.operation);
  if (!["add", "subtract", "multiply", "divide", "power"].includes(op)) return false;
  out.operation = op;
  out.value = action.value;
  if (action.component) {
    out.component = safeString(action.component);
  }
  return true;
}

function normalizeSmartDuplicate(action, out) {
  out.sourcePath = safeString(action.sourcePath);
  if (!out.sourcePath) return false;
  out.count = clampNumber(action.count, 1, MAX_SMART_DUPLICATE, 1);
  if (action.namePattern) {
    out.namePattern = safeString(action.namePattern);
  }
  if (isVector(action.positionOffset)) {
    out.positionOffset = normalizeVector(action.positionOffset);
  }
  if (isVector(action.rotationOffset)) {
    out.rotationOffset = normalizeVector(action.rotationOffset);
  }
  if (isVector(action.scaleMultiplier)) {
    out.scaleMultiplier = normalizeVector(action.scaleMultiplier);
  }
  if (action.propertyVariations && typeof action.propertyVariations === "object") {
    out.propertyVariations = action.propertyVariations;
  }
  if (Array.isArray(action.targetParents)) {
    out.targetParents = action.targetParents
      .map((p) => safeString(p))
      .filter(Boolean)
      .slice(0, MAX_SMART_DUPLICATE);
  }
  return true;
}

function normalizeInsertAsset(action, out) {
  out.assetId = typeof action.assetId === "number" ? action.assetId : parseInt(String(action.assetId), 10);
  if (!Number.isFinite(out.assetId) || out.assetId <= 0) return false;
  out.parentPath = safeString(action.parentPath, "game.Workspace");
  if (action.name) out.name = safeString(action.name);
  return true;
}

function normalizeInjectInstance(action, out) {
  out.source = safeString(action.source);
  if (!out.source) return false;
  out.description = safeString(action.description, "Injected server code");
  out.timeout = clampNumber(action.timeout, 1, 30, 10);
  return true;
}

function normalizeRunPlaytest(action, out) {
  const scenario = action.scenario && typeof action.scenario === "object" ? action.scenario : {};
  out.scenario = normalizePlaytest(scenario);
  return true;
}

// ── Registry ───────────────────────────────────────────────────────

const ACTION_NORMALIZERS = {
  create_instance: normalizeCreateInstance,
  upsert_script: normalizeUpsertScript,
  edit_script: normalizeEditScript,
  set_property: normalizeSetProperty,
  delete_instance: normalizeDeleteInstance,
  query_instances: normalizeQueryInstances,
  bulk_set_properties: normalizeBulkSetProperties,
  clone_template_to_variants: normalizeCloneTemplateToVariants,
  create_reactive_binding: normalizeCreateReactiveBinding,
  set_attribute: normalizeSetAttribute,
  add_tag: normalizeAddTag,
  remove_tag: normalizeRemoveTag,
  run_code: normalizeRunCode,
  mass_create: normalizeMassCreate,
  get_instance_properties: normalizeGetInstanceProperties,
  get_class_info: normalizeGetClassInfo,
  insert_script_lines: normalizeInsertScriptLines,
  delete_script_lines: normalizeDeleteScriptLines,
  set_relative_property: normalizeSetRelativeProperty,
  smart_duplicate: normalizeSmartDuplicate,
  insert_asset: normalizeInsertAsset,
  inject_instance: normalizeInjectInstance,
  ensure_playtest_harness: () => true,
  run_playtest: normalizeRunPlaytest,
};

// ── Public API ─────────────────────────────────────────────────────

export function normalizeAction(action) {
  if (!action || typeof action !== "object") {
    return null;
  }

  const type = safeString(action.type);
  if (!SUPPORTED_ACTIONS.has(type)) {
    return null;
  }

  const normalizer = ACTION_NORMALIZERS[type];
  if (!normalizer) return null;

  const out = { type };
  const ok = normalizer(action, out);
  if (ok === false) return null;

  // Optional one-line explanation for each action (AI-generated)
  if (typeof action.description === "string" && action.description.trim() && type !== "run_code") {
    out.description = action.description.trim().slice(0, 200);
  }

  return out;
}
